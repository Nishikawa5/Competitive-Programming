<!DOCTYPE html>
<html>
<head>
<title>Relembrar.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="dicas">Dicas</h1>
<h2 id="na-prova">Na prova</h2>
<p>Olhar os balões pelo score do site para não confundir e considerar o tempo que as questões foram feitas, além do número de questões feitas.</p>
<h2 id="boilerplate">Boilerplate</h2>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span> </span>{
    ios::sync_with_stdio(<span class="hljs-literal">false</span>);
    <span class="hljs-built_in">cin</span>.tie(<span class="hljs-literal">NULL</span>);
}

<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;
<span class="hljs-keyword">const</span> ll LINF = <span class="hljs-number">1e18</span> + <span class="hljs-number">7</span>;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> PI = <span class="hljs-built_in">acos</span>(<span class="hljs-number">-1.0</span>);
<span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> EPS = <span class="hljs-number">1e-9</span>;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    setup();
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-comment">// Para imprimir um double 'd' com 9 casas decimais</span>
<span class="hljs-keyword">double</span> d = <span class="hljs-number">0.31415926535</span>;
<span class="hljs-built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="hljs-number">9</span>) &lt;&lt; d &lt;&lt; <span class="hljs-built_in">endl</span>;
<span class="hljs-comment">// Saída: 0.314159265</span>
</div></code></pre>
<h2 id="t%C3%A9cnicas-de-resolu%C3%A7%C3%A3o-de-problemas">Técnicas de Resolução de Problemas</h2>
<h3 id="an%C3%A1lise-de-restri%C3%A7%C3%B5es">Análise de Restrições</h3>
<p>O programa demora ~1 segundo para ~
4
×
10
**8
operações. Com isso, prestar atenção nos limites de tempos das questões para não dar TLE (Time Limit Exceeded).</p>
<ul>
<li><strong>$N \le 20 \implies O(2^N \cdot N)$</strong> (Exponencial, DP com bitmask, backtracking)</li>
<li><strong>$N \le 500 \implies O(N^3)$</strong> (Floyd-Warshall, DP cúbico)</li>
<li><strong>$N \le 5000 \implies O(N^2)$</strong> (DP quadrático, grafos densos)</li>
<li><strong>$N \le 10^5 \implies O(N \log N)$</strong> (Ordenação, estruturas de dados baseadas em árvore)</li>
<li><strong>$N \le 10^7 \implies O(N)$</strong> (Processamento linear, Two Pointers)</li>
<li><strong>$N &gt; 10^7 \implies O(\log N)$ ou $O(1)$</strong> (Busca Binária, fórmulas matemáticas)</li>
</ul>
<h3 id="t%C3%A9cnicas">Técnicas</h3>
<ul>
<li><strong>Brute Force:</strong> Considere a solução mais simples.</li>
<li><strong>Busca Binária na Resposta:</strong> Se você pode verificar se uma resposta $X$ é válida, e se $X$ for válida, qualquer valor &quot;menor&quot; (ou &quot;maior&quot;) que $X$ também for, use busca binária para encontrar o melhor $X$. A função de checagem vira <code>F F F...T T T...</code>.</li>
<li><strong>Greedy:</strong> O que acontece se processarmos os itens em ordem crescente/decrescente de algum valor? Muitas vezes, isso revela uma estrutura ótima.</li>
<li><strong>Programação Dinâmica:</strong> A solução para o problema de tamanho $N$ depende das soluções para problemas de tamanho menor.</li>
<li><strong>Grafos:</strong> Modele o problema como nós e arestas.</li>
<li><strong>SegTree/BIT:</strong> Problemas de queries em ranges.</li>
<li><strong>Two Pointers/Sliding Window:</strong> Ótimo para encontrar sub-arrays/substrings que satisfazem uma condição.</li>
<li><strong>Sets, Maps, Priority Queue, Multiset</strong>: add in structure while in order</li>
<li><strong>Prefix</strong>: arr[i]++, arr[j]--, arr[i] += arr[i-1]</li>
</ul>
<h3 id="passar-vetor-por-refer%C3%AAncia">Passar vetor por referência</h3>
<p><strong>Exemplo:</strong></p>
<p>Faça:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get_size</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;a)</span> </span>{
  <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)a.size();
}
</div></code></pre>
<p>em vez de:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get_size</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; a)</span> </span>{
  <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)a.size();
}
</div></code></pre>
<p>Pois passando o vetor no segundo caso requer 𝑂(𝑛)
O(n) (vai fazer uma cópia do vetor) e pode dar erro de memória se o vetor for muito grande e estivermos fazendo várias chamadas recursivas, enquanto passando por referência (primeiro caso) requer
𝑂
(
1
)
O(1).</p>
<h2 id="map-e-unorderedmap">map e unordered_map</h2>
<p>Podemos iterar pelo map (ordenado) e unordered_map (não ordenado) com um iterador ou:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;it: <span class="hljs-built_in">map</span>) (pair&lt;&gt;)
</div></code></pre>
<p>Porém, tome cuidado, pois ao checar um elemento i que não existe no map ainda:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (mp[i])
</div></code></pre>
<p>o elemento i é adicionado no map e nesse caso também passaríamos por ele. Para fazer isso sem adicionar o elemento i no map podemos fazer:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (mp.find(i) != mp.end()) {
  <span class="hljs-comment">// código</span>
}
</div></code></pre>
<p>Tome cuidado com o uso de unordered_map, pois o número de colisões pode fazer com que o lookup fique O(n), enquanto map O(log n)</p>
<h3 id="orderedset--unorderedset">ordered_set / unordered_set</h3>
<table>
<thead>
<tr>
<th>Estrutura</th>
<th>Inserção/Deleção</th>
</tr>
</thead>
<tbody>
<tr>
<td>set</td>
<td>O(log n)</td>
</tr>
<tr>
<td>unordered_set</td>
<td>O(1) (em média)</td>
</tr>
</tbody>
</table>
<h3 id="lowerbound--upperbound">lower_bound / upper_bound</h3>
<p>lower_bound: retorna um iterador para o menor elemento maior ou igual a algum elemento k.
𝑂(log 𝑛)</p>
<p>upper_bound: retorna um iterador para o menor elemento estritamente maior que algum elemento k.
𝑂(log𝑛)</p>
<p>Funciona para set, map, vetor.</p>
<p>Exemplo:</p>
<pre class="hljs"><code><div>  1 1 1 1 1 1 2
  ^           ^   para 1
  lb          ub
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v = {<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">20</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>};

<span class="hljs-comment">// Encontra o primeiro elemento &gt;= 20</span>
<span class="hljs-keyword">auto</span> it_lb = lower_bound(v.begin(), v.end(), <span class="hljs-number">20</span>); 
<span class="hljs-comment">// it_lb aponta para o elemento no índice 1 (valor 20)</span>
<span class="hljs-keyword">int</span> idx_lb = it_lb - v.begin(); <span class="hljs-comment">// idx_lb = 1</span>

<span class="hljs-comment">// Encontra o primeiro elemento &gt; 20</span>
<span class="hljs-keyword">auto</span> it_ub = upper_bound(v.begin(), v.end(), <span class="hljs-number">20</span>);
<span class="hljs-comment">// it_ub aponta para o elemento no índice 4 (valor 30)</span>
<span class="hljs-keyword">int</span> idx_ub = it_ub - v.begin(); <span class="hljs-comment">// idx_ub = 4</span>

<span class="hljs-comment">// Se o elemento não existe, aponta para onde ele seria inserido</span>
it_lb = lower_bound(v.begin(), v.end(), <span class="hljs-number">25</span>);
<span class="hljs-comment">// it_lb aponta para o elemento no índice 4 (valor 30)</span>
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>&gt; s = {<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>};

<span class="hljs-comment">// Encontra o primeiro elemento &gt;= 25</span>
<span class="hljs-keyword">auto</span> it_lb = s.lower_bound(<span class="hljs-number">25</span>);
<span class="hljs-comment">// it_lb aponta para o elemento 30</span>
<span class="hljs-keyword">if</span> (it_lb != s.end()) {
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Lower bound de 25 é "</span> &lt;&lt; *it_lb &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// Saída: 30</span>
}

<span class="hljs-comment">// Encontra o primeiro elemento &gt; 40</span>
<span class="hljs-keyword">auto</span> it_ub = s.upper_bound(<span class="hljs-number">40</span>);
<span class="hljs-keyword">if</span> (it_ub == s.end()) {
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Não há elementos maiores que 40"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</div></code></pre>
<h3 id="otimizadores-io">Otimizadores IO</h3>
<pre class="hljs"><code><div>ios::sync_with_stdio(<span class="hljs-literal">false</span>);
<span class="hljs-built_in">cin</span>.tie(<span class="hljs-literal">NULL</span>);
</div></code></pre>
<p>Ao usá-los, não misture estilos de print do C e C++ (não utilize cout e printf no mesmo código nesse caso).</p>
<h3 id="statisticstree-sweepline">statisticsTree (sweepline)</h3>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ext/pb_ds/assoc_container.hpp&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ext/pb_ds/tree_policy.hpp&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> __gnu_pbds;

<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt; <span class="hljs-title">using</span> <span class="hljs-title">ordered_set</span> = <span class="hljs-title">tree</span>&lt;T, null_type, less&lt;T&gt;, 
rb_tree_tag, tree_order_statistics_node_update&gt;;</span>

<span class="hljs-comment">// Uso:</span>
<span class="hljs-comment">// ordered_set&lt;int&gt; s;</span>
<span class="hljs-comment">// s.insert(x);</span>
<span class="hljs-comment">// s.find_by_order(k); // Retorna iterador para o k-ésimo elemento (0-indexed)</span>
<span class="hljs-comment">// s.order_of_key(x);  // Retorna o número de elementos estritamente menores que x</span>
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ext/pb_ds/assoc_container.hpp&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ext/pb_ds/tree_policy.hpp&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> __gnu_pbds;

<span class="hljs-comment">// note que está ordenando do menor para o maior e só tem 1 elemento de cada</span>
<span class="hljs-comment">// para mais de um elemento coloque pair&lt;int, int&gt; ou algo assim</span>
<span class="hljs-keyword">typedef</span> tree&lt;
    <span class="hljs-keyword">int</span>,
    null_type,
    greater&lt;<span class="hljs-keyword">int</span>&gt;,
    rb_tree_tag,
    tree_order_statistics_node_update&gt;
statisticsTree;
</div></code></pre>
<p>Uso:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">auto</span> f = [&amp;](<span class="hljs-built_in">vector</span>&lt;pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt; lines) {
    sort(lines.begin(), lines.end());
    statisticsTree ord;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;p: lines) {
        <span class="hljs-comment">// verifica qual posição p.second está</span>
        max_slices += ord.order_of_key(p.second);
        ord.insert(p.second);
    }
    <span class="hljs-keyword">return</span>;
};
</div></code></pre>
<h3 id="segment-tree">Segment Tree</h3>
<p>Útil para queries em range.</p>
<p>Exemplo:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">MinSegmentTree</span> {</span>
<span class="hljs-keyword">private</span>:
    <span class="hljs-keyword">const</span> T DEFAULT = numeric_limits&lt;T&gt;().max();
    <span class="hljs-built_in">vector</span>&lt;T&gt; segTree;
    <span class="hljs-keyword">int</span> len;

<span class="hljs-keyword">public</span>:
    MinSegmentTree (<span class="hljs-keyword">int</span> segTree_len) {
        len = segTree_len;
        segTree = <span class="hljs-built_in">vector</span>&lt;T&gt;(len * <span class="hljs-number">2</span>, DEFAULT);
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-keyword">int</span> idx, T val)</span> </span>{
        idx += len;
        segTree[idx] = val;
        
        <span class="hljs-comment">// update (ignoring 0)</span>
        <span class="hljs-keyword">for</span> (; idx &gt; <span class="hljs-number">1</span>; idx &gt;&gt;= <span class="hljs-number">1</span>) {
            segTree[idx &gt;&gt; <span class="hljs-number">1</span>] = min(segTree[idx], segTree[idx ^ <span class="hljs-number">1</span>]);
        }
    }

    <span class="hljs-function">T <span class="hljs-title">range_min</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>{
        T min_ = DEFAULT;

        <span class="hljs-keyword">for</span> (l += len, r += len; l &lt; r; l &gt;&gt;= <span class="hljs-number">1</span>, r &gt;&gt;= <span class="hljs-number">1</span>) {
            <span class="hljs-keyword">if</span> (l &amp; <span class="hljs-number">1</span>) min_ = min(min_, segTree[l++]);
            <span class="hljs-keyword">if</span> (r &amp; <span class="hljs-number">1</span>) min_ = min(min_, segTree[--r]);
        }
        <span class="hljs-keyword">return</span> min_;
    }
};
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">SumSegmentTree</span> {</span>

  <span class="hljs-keyword">private</span>:

	<span class="hljs-keyword">const</span> T DEFAULT = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">int</span> len;
	<span class="hljs-built_in">vector</span>&lt;T&gt; segtree;

	<span class="hljs-function">T <span class="hljs-title">combine</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T &amp;a, <span class="hljs-keyword">const</span> T &amp;b)</span> </span>{ <span class="hljs-keyword">return</span> a + b; }


    <span class="hljs-comment">// [at left, at right]</span>
    <span class="hljs-comment">// by at*2 we go to the left, so the new range is </span>
    <span class="hljs-comment">// [at left, mid]</span>

    <span class="hljs-comment">// by at*2+1 we go to the right, so the new range is </span>
    <span class="hljs-comment">// [mid+1, at right]</span>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;T&gt; &amp;arr, <span class="hljs-keyword">int</span> at, <span class="hljs-keyword">int</span> at_left, <span class="hljs-keyword">int</span> at_right)</span> </span>{

		<span class="hljs-keyword">if</span> (at_left == at_right) {
			segtree[at] = arr[at_left];
			<span class="hljs-keyword">return</span>;
		}

		<span class="hljs-keyword">int</span> mid = (at_left + at_right) / <span class="hljs-number">2</span>;

        build(arr, <span class="hljs-number">2</span> * at, at_left, mid);
		build(arr, <span class="hljs-number">2</span> * at + <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, at_right);

        segtree[at] = combine(segtree[<span class="hljs-number">2</span> * at], segtree[<span class="hljs-number">2</span> * at + <span class="hljs-number">1</span>]);
	}


	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ind, T val, <span class="hljs-keyword">int</span> at, <span class="hljs-keyword">int</span> at_left, <span class="hljs-keyword">int</span> at_right)</span> </span>{

		<span class="hljs-keyword">if</span> (at_left == at_right) {
			segtree[at] = val;
			<span class="hljs-keyword">return</span>;
		}

		<span class="hljs-keyword">int</span> mid = (at_left + at_right) / <span class="hljs-number">2</span>;

		<span class="hljs-keyword">if</span> (ind &lt;= mid) {
			<span class="hljs-built_in">set</span>(ind, val, <span class="hljs-number">2</span> * at, at_left, mid);
		} <span class="hljs-keyword">else</span> {
			<span class="hljs-built_in">set</span>(ind, val, <span class="hljs-number">2</span> * at + <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, at_right);
		}

		segtree[at] = combine(segtree[<span class="hljs-number">2</span> * at], segtree[<span class="hljs-number">2</span> * at + <span class="hljs-number">1</span>]);
	}

    <span class="hljs-function">T <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ind, <span class="hljs-keyword">int</span> at, <span class="hljs-keyword">int</span> at_left, <span class="hljs-keyword">int</span> at_right)</span> </span>{

        <span class="hljs-keyword">if</span> (at_left == at_right) {
            <span class="hljs-keyword">return</span> segtree[at];
        }

        <span class="hljs-keyword">int</span> mid = at_left + (at_right - at_left) / <span class="hljs-number">2</span>;

        <span class="hljs-keyword">if</span> (ind &lt;= mid) {
            <span class="hljs-keyword">return</span> get(ind, <span class="hljs-number">2</span> * at, at_left, mid);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> get(ind, <span class="hljs-number">2</span> * at + <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, at_right);
        }
    }


	<span class="hljs-function">T <span class="hljs-title">range_sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end, <span class="hljs-keyword">int</span> at, <span class="hljs-keyword">int</span> at_left, <span class="hljs-keyword">int</span> at_right)</span> </span>{
		<span class="hljs-keyword">if</span> (at_right &lt; start || end &lt; at_left) { <span class="hljs-keyword">return</span> DEFAULT; }
		<span class="hljs-keyword">if</span> (start &lt;= at_left &amp;&amp; at_right &lt;= end) { <span class="hljs-keyword">return</span> segtree[at]; }

		<span class="hljs-keyword">int</span> mid = (at_left + at_right) / <span class="hljs-number">2</span>;

		T left_res = range_sum(start, end, <span class="hljs-number">2</span> * at, at_left, mid);
		T right_res = range_sum(start, end, <span class="hljs-number">2</span> * at + <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, at_right);

        <span class="hljs-keyword">return</span> combine(left_res, right_res);
	}


  <span class="hljs-keyword">public</span>:
	SumSegmentTree(<span class="hljs-keyword">int</span> len) : len(len) { segtree = <span class="hljs-built_in">vector</span>&lt;T&gt;(len * <span class="hljs-number">4</span>, DEFAULT); };

	SumSegmentTree(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;T&gt; &amp;arr) : len(arr.size()) {
		segtree = <span class="hljs-built_in">vector</span>&lt;T&gt;(len * <span class="hljs-number">4</span>, DEFAULT);
		build(arr, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>);
	}


	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ind, T val)</span> </span>{ 
        <span class="hljs-comment">// at 1 since we start at the root</span>
        <span class="hljs-built_in">set</span>(ind, val, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>); 
    }

    <span class="hljs-function">T <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ind)</span> </span>{
        <span class="hljs-keyword">return</span> get(ind, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, len<span class="hljs-number">-1</span>);
    }

	<span class="hljs-function">T <span class="hljs-title">range_sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>{ <span class="hljs-keyword">return</span> range_sum(start, end, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>); }
};


</div></code></pre>
<h3 id="fenwick-tree-bit">Fenwick Tree (BIT)</h3>
<p>Para queries de soma em prefixo e updates em um ponto ($O(\log N)$).</p>
<pre class="hljs"><code><div><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">FenwickTree</span> {</span>
<span class="hljs-keyword">private</span>:
    <span class="hljs-built_in">vector</span>&lt;T&gt; bit;
    <span class="hljs-keyword">int</span> size;
<span class="hljs-keyword">public</span>:
    FenwickTree(<span class="hljs-keyword">int</span> sz) : size(sz), bit(sz + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>) {}

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> idx, T delta)</span> </span>{
        <span class="hljs-keyword">for</span> (++idx; idx &lt;= size; idx += idx &amp; -idx) bit[idx] += delta;
    }

    <span class="hljs-function">T <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> idx)</span> </span>{
        T sum = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (++idx; idx &gt; <span class="hljs-number">0</span>; idx -= idx &amp; -idx) sum += bit[idx];
        <span class="hljs-keyword">return</span> sum;
    }
    
    <span class="hljs-function">T <span class="hljs-title">query_range</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>{
        <span class="hljs-keyword">return</span> query(r) - query(l - <span class="hljs-number">1</span>);
    }
};
</div></code></pre>
<h3 id="bitset">Bitset</h3>
<p>Para utilizar operações de bits em uma string de bits com mais de 64 bits podemos usar o bitset. Ele suporta as bitwise operations e podem ser usados como vetor (por exemplo, utilizar [] para acessar, além de ser possível passar para string)</p>
<pre class="hljs"><code><div><span class="hljs-built_in">bitset</span>&lt;size&gt; variable_name;
</div></code></pre>
<h3 id="grafos">Grafos</h3>
<ul>
<li><strong>Representação:</strong> Lista de adjacência <code>vector&lt;pii&gt; adj[N];</code></li>
<li><strong>BFS (Busca em Largura):</strong> Caminho mínimo em grafos com peso 1.</li>
<li><strong>DFS (Busca em Profundidade):</strong> Conectividade, ciclos, ordenação topológica.</li>
<li><strong>Dijkstra:</strong> Caminho mínimo com pesos não-negativos. Use com <code>priority_queue</code>.</li>
<li><strong>Kruskal:</strong> Árvore Geradora Mínima (MST). Use com DSU.</li>
</ul>
<h4 id="dijkstra-caminho-m%C3%ADnimo-com-pesos-n%C3%A3o-negativos">Dijkstra (Caminho Mínimo com Pesos Não-Negativos)</h4>
<p>Usa uma <code>priority_queue</code> para encontrar o caminho mais curto de um nó de origem para todos os outros.</p>
<ul>
<li><strong>Complexidade:</strong> $O(E \log V)$</li>
<li><strong>Representação:</strong> Lista de adjacência <code>vector&lt;pii&gt; adj[N];</code> onde <code>pii</code> é <code>{peso, vizinho}</code>.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;ll&gt; <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;pii&gt;&gt;&amp; adj)</span> </span>{
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;ll&gt; <span class="hljs-title">dist</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, LINF)</span></span>;
    dist[start] = <span class="hljs-number">0</span>;
    
    <span class="hljs-comment">// Fila de prioridade: {distância, nó} - min-heap</span>
    priority_queue&lt;pair&lt;ll, <span class="hljs-keyword">int</span>&gt;, <span class="hljs-built_in">vector</span>&lt;pair&lt;ll, <span class="hljs-keyword">int</span>&gt;&gt;, greater&lt;pair&lt;ll, <span class="hljs-keyword">int</span>&gt;&gt;&gt; pq;
    pq.push({<span class="hljs-number">0</span>, start});

    <span class="hljs-keyword">while</span> (!pq.empty()) {
        ll d = pq.top().first;
        <span class="hljs-keyword">int</span> u = pq.top().second;
        pq.pop();

        <span class="hljs-comment">// Otimização: se já achamos um caminho melhor, ignora</span>
        <span class="hljs-keyword">if</span> (d &gt; dist[u]) {
            <span class="hljs-keyword">continue</span>;
        }

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; edge : adj[u]) {
            <span class="hljs-keyword">int</span> v = edge.second;
            <span class="hljs-keyword">int</span> weight = edge.first;
            <span class="hljs-keyword">if</span> (dist[u] + weight &lt; dist[v]) {
                dist[v] = dist[u] + weight;
                pq.push({dist[v], v});
            }
        }
    }
    <span class="hljs-keyword">return</span> dist;
}
</div></code></pre>
<h4 id="kruskal-%C3%A1rvore-geradora-m%C3%ADnima---mst">Kruskal (Árvore Geradora Mínima - MST)</h4>
<p>Encontra um subconjunto de arestas que conecta todos os vértices com o menor custo total possível.</p>
<ul>
<li><strong>Complexidade:</strong> $O(E \log E)$</li>
<li><strong>Dependência:</strong> Estrutura DSU (Union-Find).</li>
<li><strong>Representação:</strong> Vetor de arestas <code>{peso, u, v}</code>.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DSU</span> {</span>
    vi parent;
    DSU(<span class="hljs-keyword">int</span> n) {
        parent.resize(n + <span class="hljs-number">1</span>);
        iota(parent.begin(), parent.end(), <span class="hljs-number">0</span>);
    }
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>{
        <span class="hljs-keyword">if</span> (parent[i] == i) <span class="hljs-keyword">return</span> i;
        <span class="hljs-keyword">return</span> parent[i] = find(parent[i]); <span class="hljs-comment">// Path compression</span>
    }
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unite</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>{
        <span class="hljs-keyword">int</span> root_i = find(i);
        <span class="hljs-keyword">int</span> root_j = find(j);
        <span class="hljs-keyword">if</span> (root_i != root_j) {
            parent[root_i] = root_j;
        }
    }
};

<span class="hljs-comment">// Arestas do grafo</span>
<span class="hljs-built_in">vector</span>&lt;tuple&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt; edges; <span class="hljs-comment">// {peso, u, v}</span>

<span class="hljs-function">ll <span class="hljs-title">kruskal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
    <span class="hljs-comment">// 1. Ordena as arestas pelo peso</span>
    sort(edges.begin(), edges.end());

    <span class="hljs-comment">// 2. Inicializa DSU</span>
    <span class="hljs-function">DSU <span class="hljs-title">dsu</span><span class="hljs-params">(n)</span></span>;
    
    ll mst_cost = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> edges_count = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; edge : edges) {
        <span class="hljs-keyword">auto</span> [weight, u, v] = edge;
        
        <span class="hljs-comment">// 3. Se u e v não estão no mesmo componente</span>
        <span class="hljs-keyword">if</span> (dsu.find(u) != dsu.find(v)) {
            mst_cost += weight;
            dsu.unite(u, v);
            edges_count++;
            <span class="hljs-comment">// Otimização: para quando a MST estiver completa</span>
            <span class="hljs-keyword">if</span> (edges_count == n - <span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>;
        }
    }
    
    <span class="hljs-comment">// Opcional: checar se o grafo é conexo</span>
    <span class="hljs-keyword">if</span> (edges_count &lt; n - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Não foi possível formar a MST</span>

    <span class="hljs-keyword">return</span> mst_cost;
}
</div></code></pre>
<h4 id="topological-sort">Topological sort</h4>
<pre class="hljs"><code><div><span class="hljs-comment">// n = número de vértices</span>
<span class="hljs-comment">// adj = lista de adjacência do grafo direcionado</span>
<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">topological_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; adj)</span> </span>{
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">in_degree</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> u = <span class="hljs-number">1</span>; u &lt;= n; ++u) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v : adj[u]) {
            in_degree[v]++;
        }
    }

    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; q;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) {
        <span class="hljs-keyword">if</span> (in_degree[i] == <span class="hljs-number">0</span>) {
            q.push(i);
        }
    }

    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; result;
    <span class="hljs-keyword">while</span> (!q.empty()) {
        <span class="hljs-keyword">int</span> u = q.front();
        q.pop();
        result.push_back(u);

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v : adj[u]) {
            in_degree[v]--;
            <span class="hljs-keyword">if</span> (in_degree[v] == <span class="hljs-number">0</span>) {
                q.push(v);
            }
        }
    }

    <span class="hljs-comment">// Se result.size() &lt; n, o grafo tem um ciclo</span>
    <span class="hljs-keyword">if</span> (result.size() &lt; n) {
        <span class="hljs-keyword">return</span> {}; <span class="hljs-comment">// Retorna vetor vazio para indicar ciclo</span>
    }

    <span class="hljs-keyword">return</span> result;
}
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-comment">// DFS example</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pupil, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;colors, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; &amp;graph)</span> </span>{
    <span class="hljs-comment">// cant be the same color as the pupil</span>
    <span class="hljs-keyword">int</span> friend_color = colors[pupil] == <span class="hljs-number">1</span> ? <span class="hljs-number">2</span> : <span class="hljs-number">1</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> &amp;f: graph[pupil]) {
        <span class="hljs-keyword">if</span> (colors[f] == <span class="hljs-number">0</span>) {
            <span class="hljs-comment">// just change it</span>
            colors[f] = friend_color;
            <span class="hljs-keyword">if</span> (!dfs(f, colors, graph)) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (colors[f] != friend_color) {
            <span class="hljs-comment">// can't have</span>
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">int</span> n, friendships;
    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; friendships;

    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">colors</span><span class="hljs-params">(n)</span></span>;
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">graph</span><span class="hljs-params">(n)</span></span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; friendships; i++) {
        <span class="hljs-keyword">int</span> f1, f2;
        <span class="hljs-built_in">cin</span> &gt;&gt; f1 &gt;&gt; f2;
        graph[f1 - <span class="hljs-number">1</span>].push_back(f2 - <span class="hljs-number">1</span>);
        graph[f2 - <span class="hljs-number">1</span>].push_back(f1 - <span class="hljs-number">1</span>);
    }

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
        <span class="hljs-keyword">if</span> (colors[i] == <span class="hljs-number">0</span>) {
            <span class="hljs-comment">// put in the group 1</span>
            colors[i] = <span class="hljs-number">1</span>;
            <span class="hljs-keyword">if</span> (!dfs(i, colors, graph)) {
                <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"IMPOSSIBLE\n"</span>;
                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
            }
        }
    }

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> c: colors) {
        <span class="hljs-built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="hljs-string">" "</span>;
    }
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n"</span>;
}
</div></code></pre>
<h3 id="matem%C3%A1tica">Matemática</h3>
<ul>
<li><strong>GCD e LCM</strong></li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function">ll <span class="hljs-title">gcd</span><span class="hljs-params">(ll a, ll b)</span> </span>{ <span class="hljs-keyword">return</span> b == <span class="hljs-number">0</span> ? a : gcd(b, a % b); }
<span class="hljs-function">ll <span class="hljs-title">lcm</span><span class="hljs-params">(ll a, ll b)</span> </span>{ <span class="hljs-keyword">return</span> (a / gcd(a, b)) * b; }
</div></code></pre>
<ul>
<li><strong>Exponenciação Modular</strong>
Calcula $(base^{exp}) \pmod M$ em $O(\log exp)$.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function">ll <span class="hljs-title">binpow</span><span class="hljs-params">(ll base, ll <span class="hljs-built_in">exp</span>, ll mod)</span> </span>{
    ll res = <span class="hljs-number">1</span>;
    base %= mod;
    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">exp</span> &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">exp</span> % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) res = (res * base) % mod;
        base = (base * base) % mod;
        <span class="hljs-built_in">exp</span> /= <span class="hljs-number">2</span>;
    }
    <span class="hljs-keyword">return</span> res;
}
</div></code></pre>
<ul>
<li><strong>Crivo de Eratóstenes (Sieve)</strong>
Encontra todos os primos até $N$ em $O(N \log \log N)$.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">is_prime</span><span class="hljs-params">(N + <span class="hljs-number">1</span>, <span class="hljs-literal">true</span>)</span></span>;
is_prime[<span class="hljs-number">0</span>] = is_prime[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> p = <span class="hljs-number">2</span>; p * p &lt;= N; p++) {
    <span class="hljs-keyword">if</span> (is_prime[p]) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = p * p; i &lt;= N; i += p)
            is_prime[i] = <span class="hljs-literal">false</span>;
    }
}
</div></code></pre>
<h3 id="strings">Strings</h3>
<ul>
<li><strong>Hashing (Rolling Hash):</strong> Técnica para comparar substrings em $O(1)$ após um pré-processamento $O(N)$. Útil para encontrar todas as ocorrências de um padrão, palíndromos, etc.</li>
</ul>
<h3 id="monotonic-increasingdecreasing-stack">Monotonic Increasing/Decreasing Stack</h3>
<p>Um stack que mantém os números ordenados, enquanto percorre pela arr</p>
<h3 id="binary-search">Binary search</h3>
<p>Try to make an array of with a monotonic function:
[T, T, T, ..., T, F, F, ..., F] (get the last true)</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">last_true</span><span class="hljs-params">(<span class="hljs-keyword">int</span> lo, <span class="hljs-keyword">int</span> hi, function&lt;<span class="hljs-keyword">bool</span>(<span class="hljs-keyword">int</span>)&gt; f)</span> </span>{
	<span class="hljs-comment">// if none of the values in the range work, return lo - 1</span>
	lo--;
	<span class="hljs-keyword">while</span> (lo &lt; hi) {
		<span class="hljs-comment">// find the middle of the current range (rounding up)</span>
		<span class="hljs-keyword">int</span> mid = lo + (hi - lo + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;
		<span class="hljs-keyword">if</span> (f(mid)) {
			<span class="hljs-comment">// if mid works, then all numbers smaller than mid also work</span>
			lo = mid;
		} <span class="hljs-keyword">else</span> {
			<span class="hljs-comment">// if mid does not work, greater values would not work either</span>
			hi = mid - <span class="hljs-number">1</span>;
		}
	}
	<span class="hljs-keyword">return</span> lo;
}
</div></code></pre>
<p>[F, F, F, ..., F, T, T, ..., T] (get the first true)</p>
<pre class="hljs"><code><div><span class="hljs-function">ll <span class="hljs-title">first_true</span><span class="hljs-params">(ll lo, ll hi, function&lt;<span class="hljs-keyword">bool</span>(ll)&gt; f)</span> </span>{
    hi++;

    <span class="hljs-keyword">while</span> (lo &lt; hi) {
        ll mid = lo + (hi - lo) / <span class="hljs-number">2</span>;

        <span class="hljs-keyword">if</span> (f(mid)) {
            hi = mid;
        } <span class="hljs-keyword">else</span> {
            lo = mid +<span class="hljs-number">1</span>;
        }
    }
    <span class="hljs-keyword">return</span> lo;
}

<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">first_true</span><span class="hljs-params">(<span class="hljs-keyword">double</span> lo, <span class="hljs-keyword">double</span> hi, function&lt;<span class="hljs-keyword">bool</span>(<span class="hljs-keyword">double</span>)&gt; f)</span> </span>{

    <span class="hljs-keyword">while</span> (hi - lo &gt; <span class="hljs-number">1e-6</span>) {
        <span class="hljs-keyword">double</span> mid = lo + (hi - lo) / <span class="hljs-number">2</span>;

        <span class="hljs-keyword">if</span> (f(mid)) {
            hi = mid;
        } <span class="hljs-keyword">else</span> {
            lo = mid;
        }
    }
    <span class="hljs-keyword">return</span> lo;
}
</div></code></pre>
<h3 id="programa%C3%A7%C3%A3o-din%C3%A2mica">Programação Dinâmica</h3>
<ul>
<li><strong>Estado da DP:</strong> Defina <code>dp[i]...</code> como &quot;a melhor resposta para o subproblema considerando os primeiros <code>i</code> elementos&quot;.</li>
<li><strong>Recorrência:</strong> Encontre a relação entre <code>dp[i]</code> e os estados anteriores (<code>dp[i-1]</code>, <code>dp[i-2]</code>, etc.).</li>
<li><strong>Padrões Clássicos:</strong>
<ul>
<li><strong>Knapsack (Mochila):</strong> <code>dp[i][w]</code> = maior valor usando os primeiros <code>i</code> itens com capacidade <code>w</code>.</li>
<li><strong>LIS (Longest Increasing Subsequence):</strong> <code>dp[i]</code> = tamanho da LIS que termina no elemento <code>i</code>. Pode ser otimizado para $O(N \log N)$.</li>
<li><strong>LCS (Longest Common Subsequence):</strong> <code>dp[i][j]</code> = tamanho da LCS entre as strings <code>s1[0..i]</code> e <code>s2[0..j]</code>.</li>
<li><strong>DP em Grids/Matrizes:</strong> <code>dp[i][j]</code> = resposta para o sub-grid terminando em <code>(i, j)</code>.</li>
<li><strong>DP com Bitmask:</strong> Use uma máscara de bits para representar subconjuntos de itens como estado. <code>dp[mask]</code> = resposta para o subconjunto de itens representados por <code>mask</code>.</li>
<li><strong>Intervalo:</strong> <code>dp[i][j]</code> de i até j, considere todos os j para esse i, etc.</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment">// Coin example</span>
<span class="hljs-comment">// many of same coin</span>
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(target + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;
    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= target; i++) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> c: coins) {
            <span class="hljs-keyword">if</span> (i - c &gt;= <span class="hljs-number">0</span>) {
                dp[i] += dp[i - c];
                dp[i] %= (<span class="hljs-keyword">int</span>) (<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>);
            }
        }
    }

<span class="hljs-comment">// only one use coin</span>
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(target + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;
    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;
    <span class="hljs-comment">// first add every coin of one type to dont make duplicates</span>
    <span class="hljs-comment">// note that we not adding in a ordered way, but it works the same way</span>
    <span class="hljs-comment">// because we want only the number of ways</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> &amp;curr_coin: coins) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= target; i++) {
            <span class="hljs-keyword">if</span> (i - curr_coin &gt;= <span class="hljs-number">0</span>) {
                dp[i] += dp[i - curr_coin];
                dp[i] %= mod;
            }
        }
    }
    <span class="hljs-built_in">cout</span> &lt;&lt; dp[target] &lt;&lt; <span class="hljs-built_in">endl</span>;
</div></code></pre>

</body>
</html>
